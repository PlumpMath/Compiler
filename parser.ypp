%{
	#include <stdio.h>
    #include <iostream>
    	#include "ast.hpp"
    	#include "primitive.hpp"
    	#include "symtab.hpp"
	#define YYDEBUG 1

    	extern Program_ptr ast;
	int yylex(void);
	void yyerror(const char *);
%}

/* Enables verbose error messages */
%error-verbose




/*********************************************************
	Replace with your code from project 2
*********************************************************/
%token  T_RETURN
%token  T_HEX
%token  T_DEC
%token  T_OCT
%token  T_BIN
%token  T_OR
%token  T_AND
%token  T_EQ
%token  T_NEQ
%token  T_LEQ
%token  T_GEQ
%token  T_INTARRAY
%token  T_FUNCTION
%token  T_VAR
%token  T_FOR
%token  T_TYPE_INT
%token  T_IF
%token  T_ELSE
%token  T_TYPE_BOOL
%token  T_TRUE
%token  T_FALSE     
%token  T_ID     

/* WRITE ME: put all your type definitions here*/
/* WRITE ME: put all your precedence/associativity rules here*/
%left T_NEQ T_EQ T_GEQ T_LEQ '<' '>'
%left '+' '-'
%left '*' '/'
%left T_ID
%left T_AND
%left T_OR
%right '!' U_MINUS



%%
Program : Function Function_List

;
Function_List :  Function_List Function
    |
;
Function : Function_Signature Function_Body
;
Function_Signature : T_FUNCTION T_ID '(' Param_List ')' ':' Type
;
Function_Body : '{' Code_Block Return_Statement '}'
;

Param_List : T_ID ':' Type More_Parms
    |
;
More_Parms : More_Parms',' T_ID ':' Type 
    |
    ;
Type : T_TYPE_INT
    |T_TYPE_BOOL
    |T_INTARRAY'['Num']'
    ;
Return_Statement : T_RETURN Expression';'{
            ast = exprTest($2.u_expr);
}


Num : T_DEC {
    $$.u_expr = new IntLit(new Primitive($1.u_base_int));
    } 
    |T_HEX{
    $$.u_expr = new IntLit(new Primitive($1.u_base_int));
    }
    |T_OCT{
    $$.u_expr = new IntLit(new Primitive($1.u_base_int));
    }
    |T_BIN{
    $$.u_expr = new IntLit(new Primitive($1.u_base_int));
    }
    ;

 
Code_Block: Var_List Function_List Stm_List
;
Var_List: Var_List Var_Declaration 
    |
    ;
Stm_List : Stm_List Stm_Declaration 
    |
;

Var_Declaration : T_VAR T_ID Id_List ':' Type ';'
;


Id_List : Id_List ','  T_ID
|
;



Stm_Declaration : Assign ';'
    |T_IF '(' Expression ')' '{'Stm_List'}'
    |T_IF '(' Expression ')' '{'Stm_List'}'
    T_ELSE '{'Stm_List'}'
    |T_FOR '(' Optional_Assign '('Expression')'Optional_Assign ')' 
    '{'Stm_List'}'

;


Expression    : Expression '*' Expression {

                    $$.u_expr = new Times($1.u_expr, $3.u_expr);
                }
        | Expression '/' Expression{
            $$.u_expr = new Div($1.u_expr, $3.u_expr);
        }
        | Expression '+' Expression { 
            $$.u_expr = new Plus($1.u_expr, $3.u_expr);
        }
        | Expression '-' Expression{
            $$.u_expr = new Minus($1.u_expr, $3.u_expr);
        }
        | Expression T_NEQ Expression{
            $$.u_expr = new Noteq($1.u_expr, $3.u_expr);
        }
        | Expression T_EQ Expression{
            $$.u_expr = new Compare($1.u_expr, $3.u_expr);
        }
        | Expression T_LEQ Expression{
            $$.u_expr = new Lteq($1.u_expr, $3.u_expr);
        }
        | Expression T_GEQ Expression{
            $$.u_expr = new Gteq($1.u_expr, $3.u_expr);
        }
        | Expression T_AND Expression{
            $$.u_expr = new And($1.u_expr, $3.u_expr);
        }
        | Expression T_OR Expression{
            $$.u_expr = new Or($1.u_expr, $3.u_expr);
        }
        | Expression '>' Expression{
            $$.u_expr = new Gt($1.u_expr, $3.u_expr);
        }
        | Expression '<' Expression{
            $$.u_expr = new Lt($1.u_expr, $3.u_expr);
        }
        | '(' Expression ')'
        {
            //TODO FIGURE OUT WHAT GOES HERE!!!!!!!!!
        }
        | Num 
        {
            $$.u_expr=$1.u_expr;
        }
        | T_TRUE
        | T_FALSE
        | T_ID {
            $$.u_expr = new Ident(new SymName($1.u_base_charptr));
        }
        |Array_Call
        |'-'Expression %prec U_MINUS 
        |'!' Expression
        |'|'Expression'|'
        ;
Call_List : Expression Call_Prime
|
;

Call_Prime : Call_Prime ',' Expression
|
;
Function_Call : T_ID '('Call_List')'
;

Array_Call: T_ID '['Num']';


Optional_Assign :  Assign ';'
|
;

Assign : T_ID  '=' Expression
|T_ID '='  Function_Call
|T_ID '['Expression']' '=' Expression
|T_ID '['Expression']' '=' Function_Call


%%
/*********************************************************
	Stop here
*********************************************************/




extern int yylineno;

void yyerror(const char *s) {
	fprintf(stderr, "%s at line %d\n", s, yylineno);
	return;
}
