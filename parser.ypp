%{
	#include <stdio.h>
    #include <iostream>
    	#include "ast.hpp"
    	#include "primitive.hpp"
    	#include "symtab.hpp"
	#define YYDEBUG 1

    	extern Program_ptr ast;
	int yylex(void);
	void yyerror(const char *);
%}

/* Enables verbose error messages */
%error-verbose




/*********************************************************
	Replace with your code from project 2
*********************************************************/
%token  T_RETURN
%token  T_HEX
%token  T_DEC
%token  T_OCT
%token  T_BIN
%token  T_OR
%token  T_AND
%token  T_EQ
%token  T_NEQ
%token  T_LEQ
%token  T_GEQ
%token  T_INTARRAY
%token  T_FUNCTION
%token  T_VAR
%token  T_FOR
%token  T_TYPE_INT
%token  T_IF
%token  T_ELSE
%token  T_TYPE_BOOL
%token  T_TRUE
%token  T_FALSE     
%token  T_ID     

/* WRITE ME: put all your type definitions here*/
/* WRITE ME: put all your precedence/associativity rules here*/
%left T_NEQ T_EQ T_GEQ T_LEQ '<' '>'
%left '+' '-'
%left '*' '/'
%left T_ID
%left T_AND
%left T_OR
%right '!' U_MINUS



%%
Program : Function Function_List

;
Function_List :  Function_List Function
    |
;
Function : Function_Signature Function_Body
;
Function_Signature : T_FUNCTION T_ID '(' Param_List ')' ':' Type
;
Function_Body : '{' Code_Block Return_Statement '}'
;

Param_List : T_ID ':' Type More_Parms
    |
;
More_Parms : More_Parms',' T_ID ':' Type 
    |
    ;
Type : T_TYPE_INT
    |T_TYPE_BOOL
    |T_INTARRAY'['Num']'
    ;
Return_Statement : T_RETURN Expression';'{
    $$.u_return = new ReturnImpl($2.u_expr);
    //ast = retTest($$.u_return);
}


Num : T_DEC {
    $$.u_expr = new IntLit(new Primitive($1.u_base_int));
    } 
    |T_HEX{
    $$.u_expr = new IntLit(new Primitive($1.u_base_int));
    }
    |T_OCT{
    $$.u_expr = new IntLit(new Primitive($1.u_base_int));
    }
    |T_BIN{
    $$.u_expr = new IntLit(new Primitive($1.u_base_int));
    }
    ;

 
Code_Block: Var_List Function_List Stm_List
;
Var_List: Var_List Var_Declaration 
    |
    ;
Stm_List : Stm_List Stm_Declaration 
{
    $1.u_stat_list -> push_back(($2.u_stat));
    $$.u_stat_list=$1.u_stat_list;
    Return *  ret;
    ret = new ReturnImpl(new BoolLit(new Primitive(1)));
    ast = statTest($$.u_stat_list, ret);
}
    |
{
    $$.u_stat_list = new list<Stat_ptr>();
}
;

Var_Declaration : T_VAR T_ID Id_List ':' Type ';'
;


Id_List : Id_List ','  T_ID
|
;



Stm_Declaration : Assign ';'
{
    $$.u_stat = $1.u_stat;
}
    |T_IF '(' Expression ')' '{'Stm_List'}'{
    $$.u_stat = new IfNoElse($3.u_expr,new Nested_blockImpl($6.u_stat_list));
        }
    |T_IF '(' Expression ')' '{'Stm_List'}'    
    T_ELSE '{'Stm_List'}'{
        $$.u_stat = new IfWithElse($3.u_expr,new Nested_blockImpl($6.u_stat_list)
                ,new Nested_blockImpl($10.u_stat_list));
    }
    |T_FOR '(' Optional_Assign '('Expression')'Optional_Assign ')' 
    '{'Stm_List'}'{
       $$.u_stat =  new ForLoop($3.u_stat,$5.u_expr, $7.u_stat
        ,new Nested_blockImpl($10.u_stat_list));
    }

;


Expression    : Expression '*' Expression {

                    $$.u_expr = new Times($1.u_expr, $3.u_expr);
                }
        | Expression '/' Expression{
            $$.u_expr = new Div($1.u_expr, $3.u_expr);
        }
        | Expression '+' Expression { 
            $$.u_expr = new Plus($1.u_expr, $3.u_expr);
        }
        | Expression '-' Expression{
            $$.u_expr = new Minus($1.u_expr, $3.u_expr);
        }
        | Expression T_NEQ Expression{
            $$.u_expr = new Noteq($1.u_expr, $3.u_expr);
        }
        | Expression T_EQ Expression{
            $$.u_expr = new Compare($1.u_expr, $3.u_expr);
        }
        | Expression T_LEQ Expression{
            $$.u_expr = new Lteq($1.u_expr, $3.u_expr);
        }
        | Expression T_GEQ Expression{
            $$.u_expr = new Gteq($1.u_expr, $3.u_expr);
        }
        | Expression T_AND Expression{
            $$.u_expr = new And($1.u_expr, $3.u_expr);
        }
        | Expression T_OR Expression{
            $$.u_expr = new Or($1.u_expr, $3.u_expr);
        }
        | Expression '>' Expression{
            $$.u_expr = new Gt($1.u_expr, $3.u_expr);
        }
        | Expression '<' Expression{
            $$.u_expr = new Lt($1.u_expr, $3.u_expr);
        }
        | '(' Expression ')'
        {
            //TODO FIGURE OUT WHAT GOES HERE!!!!!!!!!
        }
        | Num 
        {
            $$.u_expr=$1.u_expr;
        }
        | T_TRUE {
            $$.u_expr = new BoolLit(new Primitive(1));
        }
        | T_FALSE{
            $$.u_expr = new BoolLit(new Primitive(0));
        }
        | T_ID {
            $$.u_expr = new Ident(new SymName($1.u_base_charptr));
        }
        |Array_Call
        |'-'Expression{$$.u_expr = new Uminus($2.u_expr);} %prec U_MINUS 
        |'!' Expression {
            $$.u_expr = new Not($2.u_expr);
        }
        |'|'Expression'|' {$$.u_expr = new Magnitude($2.u_expr);}
        ;
Call_List : Expression Call_Prime
|
;

Call_Prime : Call_Prime ',' Expression
|
;

Function_Call : T_ID '('Call_List')'
;

Array_Call: T_ID '['Num']';


Optional_Assign :  Assign ';'{$$.u_stat_list = $1.u_stat_list};
| {$$.u_stat = new None();}
;

Assign : T_ID  '=' Expression {$$.u_stat = new Assignment(new SymName($1.u_base_charptr), $3.u_expr);}
|T_ID '='  Function_Call
|T_ID '['Expression']' '=' Expression
|T_ID '['Expression']' '=' Function_Call


%%
/*********************************************************
	Stop here
*********************************************************/




extern int yylineno;

void yyerror(const char *s) {
	fprintf(stderr, "%s at line %d\n", s, yylineno);
	return;
}
